Итак, мы разобрались, зачем был придуман JavaScript и как он изменялся по мере выхода новых спецификаций.

Сейчас стоит поговорить о том, что представляет JS из себя программно, какие концепции реализует, и какие приложения позволяет разрабатывать


# Снова: что такое JavaScript?

https://learn.javascript.ru/intro#chto-takoe-javascript


JavaScript - это скриптовый ЯП, который позволяет разрабатывать приложения, которые запускаются в браузере, на сервере и на других платформах.

Основными особенностями языка я выделил бы:
- динамическая типизация
- система прототипов
- интерпретируемость кода
- _асинхронные операции_ и AJAX

## Динамическая типизация

https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F

_Динами́ческая типиза́ция_ — приём, широко используемый в языках программирования и языках спецификации, при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Таким образом, в различных участках программы одна и та же переменная может принимать значения разных типов. Примеры языков с динамической типизацией — Smalltalk, Python, Objective-C, Ruby, PHP, Perl, JavaScript, Lisp, xBase, Erlang, Visual Basic.

Противоположный приём — статическая типизация.

## Система прототипов

https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5


Как говорилось ранее, создатель JavaScript, Брендан Айк, вдохновлялся также языком Self (который является диалектом популярного в 80х языка Smalltalk).

Self - это объектно-ориентированный язык, однако в отличии от других популярных объектно-ориентированных языков опираюющихся на понятие _классов_(как Java/С#/C++) он основан на концепции _прототипов_.

Прототипное программирование — стиль объектно-ориентированного программирования, при котором отсутствует понятие класса, а наследование производится путём клонирования существующего экземпляра объекта — прототипа.

## Интерпретируемость кода

Для выполнения кода на любом языке, требуется его _транслировать_, то есть перевести в машинные команды, так как только их понимает ваш компьютер.

_Транслятор_ может быть реализован в виде _компилятора_ и _интерпретатора_.

_Компилятор_ переводит текст программы в машинный код и отдает _бинарный исполняемый файл_ (бинарник).

_Интерпретатор_ выполняет код без перевода в машинный код, а проводя только синтаксический анализ.

Именно _интерпретатор_ выполняет код на JavaScript.

Самым популярным движком для интерпретации JS является **Google V8**.


# Google V8

Официальная страничка: https://v8.dev/

Подробная информация: https://habr.com/company/ruvds/blog/337460/

Движок с открытым кодом _V8_ был создан компанией Google, он написан на C++. Движок используется в браузере _Google Chrome_.

Кроме того, что отличает V8 от других движков, он применяется в популярной серверной среде **Node.js**.

При проектировании V8 разработчики задались целью улучшить производительность JavaScript в браузерах. Для того, чтобы добиться высокой скорости выполнения программ, V8 транслирует JS-код в более эффективный машинный код, не используя интерпретатор. Движок компилирует JavaScript-код в машинные инструкции в ходе исполнения программы, реализуя механизм динамической компиляции, как и многие современные JavaScript-движки, например, SpiderMonkey и Rhino (Mozilla). Основное различие заключается в том, что V8 не использует при исполнении JS-программ байт-код или любой промежуточный код.

# Node.js

Отличное видео про Node.js от Sorax (хоть и немного устаревшее): https://www.youtube.com/watch?v=4P1-JwZF0Vo

Помимо клиентских программ в браузере существует несколько технологий, позволяющих, используя интерпретатор, запускать программы на JavaScript вне браузера.

Node.js - самая популярная из них.

Node.js позволяет очень легко писать _асинхронные операции_ на JavaScript

## Асинхронные операции

Полная статья: https://medium.com/devschacht/node-hero-chapter-3-cae7333c7f3d
Видео: https://www.youtube.com/watch?v=8cV4ZvHXQL4

В таких ЯП, как Java или C++ большинство операций являются _синхронными_, то есть выполняющимися _друг за другом_ в том порядке, в котором они были записаны.

В том числе имеются ввиду операции _ввода-вывода_ (input/output или просто IO).

Если вы напишете на Java такой код

```java
try(FileInputStream inputStream = new FileInputStream("foo.txt")) {
    Session IOUtils;
    String  fileContent = IOUtils.toString(inputStream);
}
```
, то основной потом будет заблокирован до тех пор, пока файл `foo.txt.` не будет прочитан, хотя во время этого можно сделать много чего полезного.

А вот синхронный код на Node.js, делающий то же самое:

```javascript
const fs = require('fs');

let content;
try {
    content = fs.readFileSync('foo.txt', 'utf-8');
} catch (ex) {
    console.log(ex);
}

console.log(content)

```

Однако мы можем выполнить этот код _асинхронно_:

```javascript
const fs = require('fs');

fs.readFile('foo.txt', 'utf-8', function (err, content) {
    if (err) {
        return console.log(err);
    }
    console.log(content);
});

console.log('Loading...');

```

Этот код сначала выведет, `Loading...` и лишь затем ошибку `err` или содержимое файла `content`.

Дело в том, что _поток выполнения_ не остановится на выполнении функции `fs.readFile`, а пойдет работать дальшн, а когда файл прочитается, он выполнит функцию(такую функцию принято назыать callback), которую мы передали в `fs.readFile` третьим параметром.

Возможно это благодаря _циклу событий_(event loop), однако об этом мы будем говорить гораздо позже.