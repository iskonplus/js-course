# props и state

# props
Источник: https://ru.reactjs.org/docs/components-and-props.html

Ранее мы узнали, что в React компонент можно объявить, например, как функцию:

```jsx
function User(props) {
  return <div>Hello, world!</div>;
}

// либо

const User = props => {
  return <div>Hello world</div>;
};
```

Такая функция принимает в качестве первого (и пока единственного) аргумента объект - мы назвали его **`props`**, сокращенно от *properties*. Вернуть эта функция должна React-элемент, записаный с помощью JSX.

Также компонент может использовать свойства объекта **`props`**, например, для отображения каких-либо данных о пользователе.

```jsx
const User = props => {
  return (
    <div>
      <h3>Name: {props.name}</h3>
      <div>Age: {props.age}</div>
    </div>
  );
};
```

Теперь, мы можем отрисовать компонент `<User />` из родительского компонента (либо с помощью функции `ReactDOM.render()`) и передать ему `props` с помощью JSX-атрибутов:

```jsx
const UserList = () => {
  return (
    <div>
      <User name="Vlad" age={27} />
      <User name="Alex" age={28} />
    </div>
  );
};
```

Таким образом, происходит следующее:

- Мы вызываем компонент `<User name="Vlad" age={27} />` при отрисовке компонента `<UserList />`;
- React вызывает компонент `User` и передает в него props-ы `{ name: 'Vlad', age: 27 }`;
- Компонент `User` возвращает React-элемент 
```html
<div>
  <h3>Name: Vlad</h3>
  <div>Age: 27</div>
</div>
```
- React DOM делает изменения в DOM нашей страницы и мы видим результат на странице.


Также React позволяет записывать компоненты с помощью [class-ов](https://learn.javascript.ru/class):

```jsx
class User extends React.Component {
  render() {
    return (
      <div>
        <h3>Name: {this.props.name}</h3>
        <div>Age: {this.props.age}</div>
      </div>
    );
  }
}
```

Такой способ будет идентичен записи компонента с помощью функций, но класс **обязан** иметь метод `render()`, а props-ы в нем доступны из `this.props`.

Таким образом, не зависимо от написания (с помощью классов или функций), компонент можно сравнить все с той же *функцией*, где props - это аргументы, вернет такая функция React-элемент, который React DOM сразу отрисует в DOM нашей странички.

Если проводить аналогии из жизни, то:
- например, компонент - это *геометрическая фигура*, треугольник, его props - это *тип*=**прямоугольный**, *гипотенуза*=25, *катет1*=**16**, *катет2*=**9**, а React DOM - это *ученик*, который *рисует* этот треугольник в тетради;
- например, компонент - это *термометр*, его props - это *количество тепла в окружающей среде*, которое компонент отображает в виде числового значения *температуры*;
- например, компонент - это двигатель автомобиля, его props - это _количество топлива_ впрыскиваемое в его цилиндры, а результатом работы компонента является крутящий момент, который передастся трансмиссии, а далее и колесам;
- например, компонент - это выключатель в комнате, его единственный prop - это *состояние*=**влк** либо **выкл**, результатом работы является то, светло ли в комнате в темное время суток.

При работе с компонентами и `props`-ами существует несколько правил:
- вы не должны изменять props-ы, их можно только использовать для отображения или рассчетов (https://medium.com/devschacht/robin-pokorny-do-pure-functions-exist-in-javascript-94fd25180fdc).
- в компоненте классе React сам присваивает переданные props-ы, в `this.props`, однако в функциональном компоненте React передает их в качестве первого агрумента. Да, вы можете назвать этот аргумент как угодно, но тем не менее стоит его называть только и только `props`;
- для компонентов классов _обязательно_ наследование от `React.Component` либо `React.PureComponent`(о котором мы будем говорить в будущем), а также наличие метода `render()`.


## Реактивность и state
Источник: https://ru.reactjs.org/docs/state-and-lifecycle.html

### Реактивность

Ранее мы говорили только об объекте `props`, который является по своей сути "внешним" состоянием компонента.

То есть не сам компонент в случае с `props` решает как себя вести, он лишь "подчиняется воле" внешнего(родительского) компонента или функции `ReactDOM.render()`.

Это значит, что изменения `props` (изменение всего объект `props`, либо одного из его свойств), вызовет изменение компонента. Приведу пример:

- Пусть мы имеем компонент 
```jsx
const Count = props => {
  return <div>props.number</div>;
}
```
- Мы его отрисовываем с помощью `ReactDOM.render()`:
```jsx
const renderCount(n) => {
  ReactDOM.render(
    <Count number={n} />,
    documnt.getElementById('root')
  )
}

renderCount(0);
```
- мы получим число **0** на экране
- далее мы обернем `renderCount()` в `setInterval()`:
```jsx
let n = 0;
setInterval(() => renderCount(n++), 1000);
```
- в таком случае число на экране будет увеличиваться на 1 каждую секунду.

В этом примере изменение внешней переменной, а следовательно и prop-а `number` вызвало перерендеринг компонента `<Count />`, а значит и связанного с ним DOM элемента.

Таким образом оправдывается название React - ведь такое название не потому, что библиотека *реактивно* быстраая, а потому что она **reacts**(реагирует) на изменения данных и перерисовывает DOM в соответствии с ними.

### state

Компонентный подход говорит нам о том, что весь функционал нашего приложения мы разбиваем на самостоятельные кирпичики, а значит примера с локальной переменной и `ReactDOM.render()` из раздела выше явно недостаточно.

В реальном сложном приложении мы должны уметь использовать одни компоненты в других, в глубокой иерархии, а `ReactDOM.render()` вызывается единожды для отрисовки всего приложения в `<div id="root"></div>`.

Мы не сможем хранить все данные в области видимости вызова `ReactDOM.render()`, так теряется вся _компонентность_.

Поэтому для **каждого** компонента необходима возможность хранить "*свои*" данные, которые можно будет отрисовывать на экран с помощью `{...}`, а также передавать в качестве props-ов дочерним компонентам. К тому же, при изменении этих "своих" данных компонент должен перерисовать свое содержимое в соответствии с _новыми_ значениями, а также передать новые значения в дочерние компоненты для перерисовки.

И такой механизм существует, называется он **state** - состояние компонента.

Имеется он _только!_ у компонентов-классов и доступен (по аналогии с props-ами) через `this.state`.

Для того, чтобы использовать state компонента, его для начала нужно проинициализировать:
```jsx
// с помощью конструктора, если нужно инициализировать state с помощью значений props.
class Counter extends React.Component {
  constructor(props) {
    super(props)

    this.state = {
      count: props.initialCount,
    };
  }
}

// либо как свойство
class Counter extends React.Component {
  state = {
    count: 0,
  }
}
```

Далее его можно использовать, например в `render()`:

```jsx
class Counter extends React.Component {
  render() {
    return (
      <div>
        <Count number={this.state.count} />
      </div>
    )
  }
}
```

Далее нам необходим способ изменить state и при этом сообщить компоненту, что нужно перерисоваться уже с новым значением. Если мы просто присвоим новое значение `this.state.count = 1`, ничего не произойдет. 

Для "правильного" обновления state-а компонента существует функция `this.setState()`. Например, давайте добавим кнопку, по нажатии на которую будем добавлять 1 к текущему значению `this.state.count`. И пусть мы пока этого не проходили, обработать нажатие на кнопку можно передав React-элементу (не пользовательскому компоненту!), функцию-обработчик атрибуту `onClick={}`:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props)

    this.state = {
      count: props.initialCount,
    };
  }

  // используйте такое написание у методов
  // в классе компонента, чтобы он не потерял
  // котекст this
  handleClick = event => {
    this.setState({
      count: this.state.count + 1,
    });
  }

  render() {
    return (
      <div>
        <button onClick={this.handleClick}>
        <Count number={this.state.count} />
      </div>
    )
  }
}
```

Таким образом, при нажатии на кнопку мы вызовем функцию `this.handleClick()`, которая вызвав `this.setState()` вызовет изменение state-а, после чего сообщит компоненту, что нужно обновиться (в том числе снова вызовется `render()`, но `this.state` уже будет обновленным).

### Подробнее о `this.setState`
Источник: https://ru.reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous

Функция `this.setState()` принимает 2 аргумента:
- Первый аргумент может быть объектом или функцией.
- В случае, если это объект, `this.setState()` изменит перечисленные в нем свойства на новые, а старые оставит прежними. В примере ниже `this.state` будет равен `{ a: 1, b: 1 }`:
```js
state = {
  a: 0,
  b: 1,
}

...

this.setState({
  a: 1,
})
```
- В случае, если аргументом является функцмя, то эта функция принимает на вход текущие `state` и `props`, и обязательно! должна возвращать объект с новыми свойствами:

```jsx
this.setState(
  (currentState, currentProps) => {
    return {
      count: currentState.count + 1,
    }
  }
)
```
- Второй аргумент функции `this.setState()` - это колбэк, который выховатся тогда, когда произойдет изменение state-а

```jsx
handleClick = event => {
  this.setState(
    currentState => ({
      count: currentState.count + 1,
    }),
    nextState => {
      alert(`current count is now: ${nextState.count})`
    }
  )
}
```

- Такой код выдаст alert после изменения state-а. Наличие колбэка говорит о том, что функция `this.setState()` является асинхронной. Поэтому если попытаться использовать `this.state` сразу _после_ вызова `this.setState()` - он будет старым:


```jsx
handleClick = event => {
  this.setState(
    currentState => ({
      count: currentState.count + 1,
    }),
    nextState => {
      console.log(`current count is now ${nextState.count})`
    }
  );

  console.log(`state is still ${this.state.count}`)
}
```

выведет в консоль

```
> state is still 0
> current count is now 1
```

## Аналогии со state и props
- предположим, что компонент - это парашютист. props для него - это ускорение свободного падения g=9.8 и время t, его текущая скорость зависит только от них. Затем он решает не разбиваться о землю и использовать свой state - парашют, и теперь его скорость снижена;

- предположим, что компонент - это будильник, мы выставляем props - время, в которое он должен прозвенеть, но именно его внутрений state - таймер, заставляет его прозвенеть, когда
`this.state.currentTime >= this.props.timeToWakeUp`;

- предположим, что компонент - это Инстаграмм, props для него - это фото, которое мы хотим залить, а state - это переключатель фильтров. При изменении фильтра конечный результат меняется.

##  Домашнее задание

### Задание 1
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date

Создайте компонент `<Clock />`, который отображает текущее время в формате `HH:mm:ss` и обновляет его каждую секунду.

Note: запустить интервал можно в lifecycle-методе `componentDidMount()`

### Задание 2
Создайте компонент `<AlarmClock />`, который принимает на вход время `time`, в которое будильник должен прозвенеть, использует функционал компонента `<Clock />` из предыдущего задания для отображения времени и выводит на экран `Wake up!` когда время придет.

Hint: `this.state.currentTime >= this.props.time`

### Задание 3

Дайте возможность `<AlarmClock />` отключить будильник.
 Для этого добавьте рядом с `Wake up` кнопку `Turn off` которая отключает будильник.
 
Hint: В таком случае, условием показа будильника будет отдельное свойство stata-а - `this.state.shouldAlarmShow`, которое необходимо выставлять в при обновлении `this.state.currentTime`

### Задание 4 (со звездочкой)

Дайте возможность не только отключать будильник, но и переводить его на 5 минут (10 секунд для удобства) вперед.

Hint: теперь `this.props.time` должно задаваться не просто как _статичный_ prop компонента `<AlarmClock />`, а как свойство state-а родительского компонента

```jsx
// было
<AlarmClock time={new Date('December 17, 1995 03:24:00')} />

// стало
<AlarmClock
  time={this.state.timeToWakeUp}
  onSnooze={/* добавить 5 минут this.state.timeToWakeUp */}
/>
```

### Задание 5

Создайте компонент `<RequiredInput />`, этот компонент должен отрисовать `<input />`, в который можно ввести значение.

Если значения в поле нет, должна быть отображена ошибка валидации: <span style="color:red">Field is required</span>

Hint:

```jsx
<input value={this.state.value} onChange={this.handleChange} />
```

### Задание 6

Создайте компонент `<RequiredEmailInput />`, этот компонент должен отрисовать `<input />`, в который можно ввести значение.

Если значения в поле нет, должна быть отображена ошибка валидации: <span style="color:red">Field is required</span>

Если значение в поле не является валидным email-ом, должна быть отображена ошибка валидации: <span style="color:red">Incorrect email</span>

Hint: проверка на email: https://stackoverflow.com/questions/46155/how-to-validate-an-email-address-in-javascript


### Задание 7 (со звездочкой):
Валидация не должна срабатывать при начальной загрузке, если ваше поле ввода не было тронуто - `touched` (имеется ввиду, что его значение еще не изменялось)

### Задание 8 (со звездочкой):

Создайте компонент `<Input />`, который на вход принимает 
пропсы `required` и `email` типа Boolean, и ведет себя следующим образом

```jsx
// будет выдавать ошибку при пустом вводе
<Input required />

// будет валидировать и пустой ввод и email
<Input email required />

// будет валидировать только email
<Input email />

// ничего не будет валидировать
<Input />
``` 

Note: в jsx атрибут(проп) типа Boolean можно передавать как

```jsx
<SomeComponent someLogicalProp={true} />
```
и как 
```jsx
<SomeComponent someLogicalProp />
```
эти записи _эквивалентны_.
Однако в случае false требуется полная форма
```jsx
<SomeComponent someLogicalProp={false} />
```

---
## Ссылки:

- https://ru.reactjs.org/docs/components-and-props.html
- https://ru.reactjs.org/docs/state-and-lifecycle.html
- https://ru.reactjs.org/docs/handling-events.html
- https://learn.javascript.ru/class
- https://www.youtube.com/watch?v=GIU8ekYndKw
- https://www.youtube.com/watch?v=ICmMVfKjEuo&list=PLN3n1USn4xlntqksY83W3997mmQPrUmqM&index=4
- https://www.youtube.com/watch?v=34fE23aib1o&list=PLN3n1USn4xlntqksY83W3997mmQPrUmqM&index=6



